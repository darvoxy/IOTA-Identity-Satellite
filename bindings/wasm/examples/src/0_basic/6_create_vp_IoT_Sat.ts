// Copyright 2020-2023 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

import {
    CoreDID,
    Credential,
    Duration,
    EdDSAJwsVerifier,
    FailFast,
    IotaIdentityClient,
    JwkMemStore,
    JwsSignatureOptions,
    JwsVerificationOptions,
    Jwt,
    JwtCredentialValidationOptions,
    JwtCredentialValidator,
    JwtPresentationOptions,
    JwtPresentationValidationOptions,
    JwtPresentationValidator,
    KeyIdMemStore,
    Presentation,
    Resolver,
    Storage,
    SubjectHolderRelationship,
    Timestamp,
} from "@iota/identity-wasm/node";
import { Client, MnemonicSecretManager, Utils } from "@iota/sdk-wasm/node";
import { API_ENDPOINT, createDid } from "../util";

/**
    Creación y validación de una Presentación Verificable.
    Una presentación verificable es el formato en el que se comparte una (colección de) credencial(es) verificable(s).
    Está firmada por el sujeto, para demostrar el control sobre la Credencial Verificable con un nonce o marca de tiempo.
 */
export async function createVP() {
    // ===========================================================================
    // Paso 1: Creación de identidades distribuidas para el emisor y el titular.
    // ===========================================================================

    const client = new Client({
        primaryNode: API_ENDPOINT,
        localPow: true,
    });

    // Cliente para conectar con el Tangle
    const didClient = new IotaIdentityClient(client);

    // crea una nueva cartera e identidad 
    const satCompanySecretManager: MnemonicSecretManager = {
        mnemonic: Utils.generateMnemonic(),
    };
    const satCompanyStorage: Storage = new Storage(
        new JwkMemStore(),
        new KeyIdMemStore(),
    );

    // Create an identity for the holder, in this case also the subject.
    const iotDeviceSecretManager: MnemonicSecretManager = {
        mnemonic: Utils.generateMnemonic(),
    };
    const iotDeviceStorage: Storage = new Storage(
        new JwkMemStore(),
        new KeyIdMemStore(),
    );

    // DIDs de SatCompany y de IoTDevice
    let { document: satCompanyDocument, fragment: satCompanyFragment } = await createDid(
        client,
        satCompanySecretManager,
        satCompanyStorage,
    );
    console.log("Sat Company DID", satCompanyDocument);

    let { document: iotDeviceDocument, fragment: iotDeviceFragment } = await createDid(
        client,
        iotDeviceSecretManager,
        iotDeviceStorage,
    );
    console.log("IoT Device DID", iotDeviceDocument);

    // ===========================================================================
    // Step 2: Issuer creates and signs a Verifiable Credential.
    // ===========================================================================

    const subject = {
        id: iotDeviceDocument.id(),
        name: "Humidity Sensor",
        sensorMAC: "00:1B:44:11:3A:B7",
        sensorType: "LoRa IoT Sensor",
        GPS: "41.40338, 2.17403",
    };

    // Create an unsigned `IoTDeviceInfo` credential for the IoTDevice
    const unsignedVc = new Credential({
        id: "https://example.edu/credentials/3732",
        type: "IoTDeviceInfoCredential",
        issuer: satCompanyDocument.id(),
        credentialSubject: subject,
    });

    const credentialJwt = await satCompanyDocument.createCredentialJwt(
        satCompanyStorage,
        satCompanyFragment,
        unsignedVc,
        new JwsSignatureOptions(),
    );

    const res = new JwtCredentialValidator(new EdDSAJwsVerifier()).validate(
        credentialJwt,
        satCompanyDocument,
        new JwtCredentialValidationOptions(),
        FailFast.FirstError,
    );
    console.log("credentialjwt validation", res.intoCredential());

    // ===========================================================================
    // Step 3: Issuer sends the Verifiable Credential to the holder.
    // ===========================================================================

    // The credential is then serialized to JSON and transmitted to the holder in a secure manner.
    // Note that the credential is NOT published to the IOTA Tangle. It is sent and stored off-chain.
    console.log(`Sending credential (as JWT) to the holder`, unsignedVc.toJSON());

    // ===========================================================================
    // Step 4: Verifier sends the holder a challenge and requests a signed Verifiable Presentation.
    // ===========================================================================

    // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
    const nonce = "475a7984-1bb5-4c4c-a56f-822bccd46440";

    // The verifier and holder also agree that the signature should have an expiry date
    // 10 minutes from now.
    const expires = Timestamp.nowUTC().checkedAdd(Duration.minutes(10));

    // ===========================================================================
    // Step 5: Holder creates a verifiable presentation from the issued credential for the verifier to validate.
    // ===========================================================================

    // Create a Verifiable Presentation from the Credential
    const unsignedVp = new Presentation({
        holder: iotDeviceDocument.id(),
        verifiableCredential: [credentialJwt],
    });

    // Create a JWT verifiable presentation using the holder's verification method
    // and include the requested challenge and expiry timestamp.
    const presentationJwt = await iotDeviceDocument.createPresentationJwt(
        iotDeviceStorage,
        iotDeviceFragment,
        unsignedVp,
        new JwsSignatureOptions({ nonce }),
        new JwtPresentationOptions({ expirationDate: expires }),
    );

    // ===========================================================================
    // Step 6: Holder sends a verifiable presentation to the verifier.
    // ===========================================================================
    console.log(
        `Sending presentation (as JWT) to the verifier`,
        unsignedVp.toJSON(),
    );

    // ===========================================================================
    // Step 7: Verifier receives the Verifiable Presentation and verifies it.
    // ===========================================================================

    // The verifier wants the following requirements to be satisfied:
    // - JWT verification of the presentation (including checking the requested challenge to mitigate replay attacks)
    // - JWT verification of the credentials.
    // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property
    // - The issuance date must not be in the future.

    const jwtPresentationValidationOptions = new JwtPresentationValidationOptions(
        {
            presentationVerifierOptions: new JwsVerificationOptions({ nonce }),
        },
    );

    const resolver = new Resolver({
        client: didClient,
    });
    // Resolve the presentation holder.
    const presentationHolderDID: CoreDID = JwtPresentationValidator.extractHolder(presentationJwt);
    const resolvedHolder = await resolver.resolve(
        presentationHolderDID.toString(),
    );

    // Validate presentation. Note that this doesn't validate the included credentials.
    let decodedPresentation = new JwtPresentationValidator(new EdDSAJwsVerifier()).validate(
        presentationJwt,
        resolvedHolder,
        jwtPresentationValidationOptions,
    );

    // Validate the credentials in the presentation.
    let credentialValidator = new JwtCredentialValidator(new EdDSAJwsVerifier());
    let validationOptions = new JwtCredentialValidationOptions({
        subjectHolderRelationship: [
            presentationHolderDID.toString(),
            SubjectHolderRelationship.AlwaysSubject,
        ],
    });

    let jwtCredentials: Jwt[] = decodedPresentation
        .presentation()
        .verifiableCredential()
        .map((credential) => {
            const jwt = credential.tryIntoJwt();
            if (!jwt) {
                throw new Error("expected a JWT credential");
            } else {
                return jwt;
            }
        });

    // Concurrently resolve the issuers' documents.
    let issuers: string[] = [];
    for (let jwtCredential of jwtCredentials) {
        let issuer = JwtCredentialValidator.extractIssuerFromJwt(jwtCredential);
        issuers.push(issuer.toString());
    }
    let resolvedIssuers = await resolver.resolveMultiple(issuers);

    // Validate the credentials in the presentation.
    for (let i = 0; i < jwtCredentials.length; i++) {
        credentialValidator.validate(
            jwtCredentials[i],
            resolvedIssuers[i],
            validationOptions,
            FailFast.FirstError,
        );
    }

    // Since no errors were thrown we know that the validation was successful.
    console.log(`VP successfully validated`);
}